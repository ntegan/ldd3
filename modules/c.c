#include <linux/fs.h>
#include <linux/init.h>
#include <linux/module.h>

MODULE_LICENSE("Dual BSD/GPL");

static int hello_init(void) {
  printk(KERN_ALERT "hello, world\n");
  printk(KERN_DEBUG "Here I am: %s:%i\n", __FILE__, __LINE__);
  printk(KERN_CRIT "I'm trashed; \n");
  return 0;
}

static void hello_exit(void) { printk(KERN_ALERT "Goodbye, cruel world\n"); }

module_init(hello_init);
module_exit(hello_exit);

//  LDD3 Chapter 4: Kernl Debugging
// https://static.lwn.net/images/pdf/LDD3/ch04.pdf
//
//  printk
//  ======
//  printk(KERN_DEBUG "Here I am: %s:%i\n", __FILE__, __LINE__);
//
//  8 possible loglevel strings defined in <linux/kernel.h>
//  printk with no priority defaults to DEFAULT_MESSAGE_LOGLEVEL
//  which is specified in kerne/printk.c as an integer.
//
//  if priority < integer var console_loglevel, then print.
//
//  if both klogd and syslogd running, kernel messages are appended
//  to /var/log/messages (depending on syslogd config), regardless of loglevel
//
//  if klogd not running, message won't reach usespace until read /proc/kmsg
//  (easily done with dmesg)
//
//  console_loglevel init'd to DEFAULT_CONSOLE_LOGLEVEL and modified through
//  sys_syslog system call.
//
//  Example of console loglevel changer in misc-progs/setlevel.c
//
//  <sys/klog.h> klogctl(..)
//
//  also echo 8 > /proc/sys/kernel/printk
//
//
//
//  Redirecting Console Messages
//  ============================
//  console policies let you send messages to a specific virtual console
//  (if console lives on the text screen).
//  by defualt, the "console" is the current virtual terminal.
//  ioctl(TIOCLINUX) on any console device to sleect diff virt term to rcv msgs
//
//  misg-procs/setconsole.c shows this example ^^
//
//  TIOCTLINUX is a special ioctl command, linux specific functions.
//  t use it, pass array pointer as an argument. to a byte array.
//  fist byte is subcmmand, fllowing are for the subcommand.
//
//  complete description of TIOCINUX is in drivers/char/tty_io.c in linux/
//
//
//  Skipped a couple sectins
//  ========================
//
//
//  using the /proc filesystem
//  ==========================
//  /proc/modules returns list of currently loaded moduelles
//
//  recommended  to use sysfs instead of procfs.
//  but need undersstanding of linux device model, we get to in chapter 14
//
//  to do so anyways, include <linux/proc_fs.h>
//  read only /proc file.
//  driver must implement funcion to produce data when file is read.
//
//  when process reads from your /proc file, kernel allocs page of mem
//  (PAGE_SIZE bytes) where driver can write data to be returned to userspace.
//
//  buffer is passed to our function, which is
//  int (*read_proc)(char *page, char **start, off_t offset, int count,
//                      int *eof, void *data);
//
//  page pointer is where drite data,
//  start used by function to say where interest data has been written in page,
//  offset and count same meaning as for read method,
//  eof points to integer that must be set by driver signal no more data to ret
//  data is driver-specific ptr to use for internal bookkeeping
//
//
//  TODO: Skipped a lot on the /proc filesystem
//
//
//
//
//
//
//  The ioctl Method
//  ================
//  syscall frm ch1
//  acts on a file descriptor, receives a number iding a command and
//  optionally another argument (usually ptr)
//
//
//  Oops Messages
//  =============
//  generated by printk statements in fault handler
//  (arch/*/kernel/traps.c)
//
//  TODO: come back here to learn how to deal with oops messages
//      when/if i start getting them

//  System Hangs
//  ============
//  Prevent infinite loop by inserting `schedule` invocations
//  at strategic points. This call invokes scheduler and allows
//  you to schedule other processes.
//
//  Do not use `schedule` if holding a spinlock or other lock.
//
//  Node the above may be irrelevant in multiprocessing systems
//
//  Magic SysRq key: see Documentation/sysrq.txt
//
//
//  GDB for debugging
//  =================
//  specify name for elf kernel image and name of core file
//  for a running kernel, core file is kernel core image
//  gdb /usr/src/linux/vmlinux /proc/kcore
//
//  kcore represents whole kernel addr space, corresponding to all physmem
//  can look at kernel variables by using gdb commands.
//  e.g. `p jiffies` to print num clock ticks from sysboot to curtime
//
//  gdb caches values, so have to command `core-file /proc/kcore`
//  when want to flush gdb cache
//
//  must compile kernel with CONFIG_DEBUG_INFO for symbol info in gdb
//
//  Debugging modules:
//  3 main important sections .text, .bss (uninit) , .data (init'd)
//  must inform gdb where each section has been loaded.
//  base addr for each section is in /sys/module/<modname>/sections
//
//  gdb command `add-symbol-file`
//  e.g. `add-symbol-file scull.ko 0x<textbaseaddr> \
//          -s .bss <addr> -s .data <addr>`
//
//  `print *(address)`
//  output is file and line number for code corresponding to addr
//  e.g. find where a function pointer really points
//
//  kernel debugger
//  ===============
//  nonofficial patch from oss.sgi.com
//
//  press Pause or Break key on a console to start debugger.
//  also starts when oops happens or breakpooiint hit.
//
//  good idea disable networking, etc. (e.g. SingUserMode) when kdb
//
//
//  kgdb
//  ====
//  more patches called kgdb allow for kern debug w/ more capabilities
//
//
//
//  User Mode Linux
//  ===============
